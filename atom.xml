<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SeasonTemple-Blog</title>
  
  
  <link href="/SeasonTemple.github.io/atom.xml" rel="self"/>
  
  <link href="http://seasontemple.top/"/>
  <updated>2019-09-27T03:59:48.289Z</updated>
  <id>http://seasontemple.top/</id>
  
  <author>
    <name>SeasonTemple</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java爬虫</title>
    <link href="http://seasontemple.top/2019/07/13/Java%E7%88%AC%E8%99%AB/"/>
    <id>http://seasontemple.top/2019/07/13/Java爬虫/</id>
    <published>2019-07-13T05:26:43.000Z</published>
    <updated>2019-09-27T03:59:48.289Z</updated>
    
    <content type="html"><![CDATA[<p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p><meta name="referrer" content="no-referrer"><h1 id="Java-爬虫"><a href="#Java-爬虫" class="headerlink" title="Java 爬虫"></a>Java 爬虫</h1><p>当需要大量数据或者说大量信息的时候，爬虫会是一种比较便捷的方式。</p><h2 id="爬虫是什么"><a href="#爬虫是什么" class="headerlink" title="爬虫是什么"></a>爬虫是什么</h2><p>既然要学习一门技术，首先就得搞清楚它关注的是什么，以及它是用来解决什么问题的。<br>网络爬虫（Web Crawler），又称为网络蜘蛛（Web Spider）或 Web 信息采集器，是一种按照一定规则，自动抓取或下载网络信息的计算机程序或自动化脚本，是目前搜索引擎的重要组成部分。</p><ul><li><strong>狭义上理解</strong>：利用标准的 HTTP 协议，根据网络超链接（如<a href="https://www.baidu.com/）和" target="_blank" rel="noopener">https://www.baidu.com/）和</a> Web 文档检索的方法（如深度优先）遍历万维网信息空间的软件程序。</li><li><strong>功能上理解</strong>：确定待爬的 URL 队列，获取每个 URL 对应的网页内容（如 HTML/JSON），解析网页内容，并存储对应的数据。</li></ul><p>一般来说，爬虫主要是搜索引擎从网络中抓取信息、采集数据的手段。<br>实际项目开发中，通过爬虫做数据采集一般只有以下几种情况：</p><ol><li><strong>搜索引擎</strong> </li><li><strong>竞品调研</strong> </li><li><strong>舆情监控</strong> </li><li><strong>市场分析</strong> </li></ol><h2 id="网络爬虫的分类"><a href="#网络爬虫的分类" class="headerlink" title="网络爬虫的分类"></a>网络爬虫的分类</h2><p><strong>网络爬虫按照系统架构和实现技术，大致可以分为以下几种类型：</strong></p><ul><li><strong>通用网络爬虫（General Purpose Web Crawler）</strong>：爬行对象从一些种子 URL 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。<br>通用网络爬虫的爬取范围和数量巨大，对于爬行速度和存储空间要求较高，对于爬行页面的顺序要求较低，通常采用并行工作方式，有较强的应用价值。</li><li><strong>聚焦网络爬虫（Focused Web Crawler）</strong>：又称为主题网络爬虫。是指选择性地爬行那些与预先定义好的主题相关的页面。<br>和通用爬虫相比，聚焦爬虫只需要爬行与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，可以很好地满足一些特定人群对特定领域信息的需求。<br>通常在设计聚焦网络爬虫时，需要加入链接和内容筛选模块。常见的案例是基于关键字获取符合用户需求的数据。</li><li><strong>增量式网络爬虫（Incremental Web Crawler）</strong>：对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面，历史已经采集过的页面不重复采集。<br>增量网络爬虫避免了重复采集数据，可以减小时间和空间上的耗费。通常在设计网络爬虫时，需要在数据库中，加入时间戳，基于时间戳上的先后，判断程序是否继续执行。<br>常见的案例有：论坛帖子评论数据的采集（如下图所示论坛的帖子，它包含400多页，每次启动爬虫时，只需爬取最近几天用户所发的帖子)；天气数据的采集；新闻数据的采集；股票数据的采集等。</li><li><strong>深层网络爬虫（Deep Web Crawler）</strong>：指大部分内容不能通过静态链接获取，只有用户提交一些表单信息才能获取的 Web 页面。例如，需要模拟登陆的网络爬虫便属于这类网络爬虫。另外，还有一些需要用户提交关键词才能获取的内容，如京东淘宝提交关键字、价格区间获取产品的相关信息。</li></ul><p><strong>而实际上，网络爬虫系统通常是几种爬虫技术相结合实现的。</strong></p><h2 id="网络爬虫的流程"><a href="#网络爬虫的流程" class="headerlink" title="网络爬虫的流程"></a>网络爬虫的流程</h2><p>网络爬虫基本流程可用下图描述：</p><p><img src="/2019/07/13/Java爬虫/爬虫的基本流程图.png" alt="爬虫基本流程图"></p><p>具体流程为：</p><ol><li>需求者选取一部分种子 URL（或初始 URL），将其放入待爬取的队列中。如在 Java 网络爬虫中，可以放入 LinkedList 或 List 中。</li><li>判断 URL 队列是否为空，如果为空则结束程序的执行，否则执行第三步骤。</li><li>从待爬取的 URL 队列中取出待爬的一个 URL，获取 URL 对应的网页内容。在此步骤需要使用响应的状态码（如200，403等）判断是否获取数据，如响应成功则执行解析操作；如响应不成功，则将其重新放入待爬取队列（注意这里需要移除无效 URL)。</li><li>针对已经响应成功后获取到的数据，执行页面解析操作。此步骤根据用户需求获取网页内容里的部分数据，如汽车论坛帖子的标题、发表的时间等。</li><li>针对3步骤已解析的数据，将其进行存储。</li></ol><h2 id="爬行策略-算法"><a href="#爬行策略-算法" class="headerlink" title="爬行策略(算法)"></a>爬行策略(算法)</h2><p>一般的网络爬虫的爬行策略分为两种：</p><p><strong>深度优先搜索（Depth-First Search）策略</strong>：从根节点的 URL 开始，根据优先级向下遍历该根节点对应的子节点。当访问到某一子节点 URL 时，以该子节点为入口，继续向下层遍历，直到没有新的子节点可以继续访问为止。接着使用回溯的方法，找到没有被访问到的节点，以类似的方式进行搜索。<br>从种子页到当前页的打开连接数，一般建议不要超过5层。<br>深度优先示意图：</p><p> <img src="/2019/07/13/Java爬虫/深度优先.png" alt="深度优先示意图"></p><p><strong>广度优先搜索（Breadth-First Search）策略</strong>：也称为宽度优先，是另外一种非常有效的搜索技术，这种方法按照按深度的层级来进行页面的遍历。<br>深度优先示意图：</p><p> <img src="/2019/07/13/Java爬虫/广度优先.png" alt="广度优先示意图"></p><p>以上两者也就是深度优先算法和广度优先算法的实际应用。而基于广度优先的爬虫是最简单的爬取网站页面的方法，也是目前使用较为广泛的方法。</p><h2 id="话不多说，先放一下初步学习一天的成果"><a href="#话不多说，先放一下初步学习一天的成果" class="headerlink" title="话不多说，先放一下初步学习一天的成果"></a>话不多说，先放一下初步学习一天的成果</h2><p>对仁慈的京东进行初步、少量(一页)的数据爬取<br>流程如下：</p><ol><li>进入京东首页，搜索框中随便输入一个商品名进行搜索(本人选择的是手机)。</li></ol><p><img src="/2019/07/13/Java爬虫/京东首页搜索商品.png" alt="京东首页搜索商品图"></p><ol start="2"><li>F12打开开发者工具栏，找到页面中商品列表<strong>标签</strong>所在位置，并分析其位置关系，定位爬取信息。</li></ol><ul><li>定位商品信息标签的父节点标签id为：J_goodsList</li></ul><p><img src="/2019/07/13/Java爬虫/定位商品信息标签的父节点.png" alt="定位商品信息标签的父节点"></p><ul><li>定位商品信息所在的li标签，选择合适的定位方法(这里选择了li中的class属性: .gl-item)：</li></ul><p><img src="/2019/07/13/Java爬虫/定位商品信息所在的li标签.png" alt="定位商品信息所在的li标签"></p><ul><li>通过商品所在的li标签中的子元素，便可获取商品的所有信息了(有空再细讲吧，先上个图意思意思)</li></ul><p><img src="/2019/07/13/Java爬虫/li标签中的子元素.png" alt="商品信息所在的li标签中的子元素"></p><h2 id="说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性"><a href="#说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性" class="headerlink" title="说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性"></a>说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性</h2><p><strong>SPU：Standard product Unit(标准产品单位) 品种名</strong><br><strong>SKU：Stok Keeping Unit(最小库存量单位) 规格类型</strong></p><p>简单来说，一个spu对应一个商品；而一个商品可以对应多个sku，因为sku指的是商品的规格。<br>举例：<br>小米8手机假设它的spu为： 1239。那么这个1239就代表了小米8这款手机，而这款手机它会有不同的颜色款式，甚至会有配置的变化(如运存大小，处理器型号)。这时就以sku来做区分。<br>例如：</p><ul><li>红色的小米8，处理器是骁龙880，价格为3444元，sku为1239(与spu一致，作为默认主图显示的款式)</li><li>红色的小米8，处理器是骁龙760，价格为2444元，sku为1233(与spu不一致，也不同于前者的sku，在缩略图显示的款式)</li><li>蓝色的小米8，处理器是骁龙860，价格为3222元，sku为1244(与spu不一致，也不同于前者的sku，在缩略图显示的款式)</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;&lt;/p&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Java-爬虫&quot;&gt;&lt;a href=&quot;#Java-爬虫&quot; class=&quot;headerlink&quot; title=&quot;Java 爬虫&quot;&gt;&lt;/a&gt;Java 爬虫&lt;/h1&gt;&lt;p&gt;当需要大量数据或者说大量信息的时候，爬虫会是一种比较便捷的方式。&lt;/p&gt;
&lt;h2 id=&quot;爬虫是什么&quot;&gt;&lt;a href=&quot;#爬虫是什么&quot; class=&quot;headerlink&quot; title=&quot;爬虫是什么&quot;&gt;&lt;/a&gt;爬虫是什么&lt;/h2&gt;&lt;p&gt;既然要学习一门技术，首先就得搞清楚它关注的是什么，以及它是用来解决什么问题的。&lt;br&gt;网络爬虫（Web Crawler），又称为网络蜘蛛（Web Spider）或 Web 信息采集器，是一种按照一定规则，自动抓取或下载网络信息的计算机程序或自动化脚本，是目前搜索引擎的重要组成部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;狭义上理解&lt;/strong&gt;：利用标准的 HTTP 协议，根据网络超链接（如&lt;a href=&quot;https://www.baidu.com/）和&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.baidu.com/）和&lt;/a&gt; Web 文档检索的方法（如深度优先）遍历万维网信息空间的软件程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能上理解&lt;/strong&gt;：确定待爬的 URL 队列，获取每个 URL 对应的网页内容（如 HTML/JSON），解析网页内容，并存储对应的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，爬虫主要是搜索引擎从网络中抓取信息、采集数据的手段。&lt;br&gt;实际项目开发中，通过爬虫做数据采集一般只有以下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;搜索引擎&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;竞品调研&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;舆情监控&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;市场分析&lt;/strong&gt; &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;网络爬虫的分类&quot;&gt;&lt;a href=&quot;#网络爬虫的分类&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫的分类&quot;&gt;&lt;/a&gt;网络爬虫的分类&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;网络爬虫按照系统架构和实现技术，大致可以分为以下几种类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通用网络爬虫（General Purpose Web Crawler）&lt;/strong&gt;：爬行对象从一些种子 URL 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。&lt;br&gt;通用网络爬虫的爬取范围和数量巨大，对于爬行速度和存储空间要求较高，对于爬行页面的顺序要求较低，通常采用并行工作方式，有较强的应用价值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚焦网络爬虫（Focused Web Crawler）&lt;/strong&gt;：又称为主题网络爬虫。是指选择性地爬行那些与预先定义好的主题相关的页面。&lt;br&gt;和通用爬虫相比，聚焦爬虫只需要爬行与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，可以很好地满足一些特定人群对特定领域信息的需求。&lt;br&gt;通常在设计聚焦网络爬虫时，需要加入链接和内容筛选模块。常见的案例是基于关键字获取符合用户需求的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增量式网络爬虫（Incremental Web Crawler）&lt;/strong&gt;：对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面，历史已经采集过的页面不重复采集。&lt;br&gt;增量网络爬虫避免了重复采集数据，可以减小时间和空间上的耗费。通常在设计网络爬虫时，需要在数据库中，加入时间戳，基于时间戳上的先后，判断程序是否继续执行。&lt;br&gt;常见的案例有：论坛帖子评论数据的采集（如下图所示论坛的帖子，它包含400多页，每次启动爬虫时，只需爬取最近几天用户所发的帖子)；天气数据的采集；新闻数据的采集；股票数据的采集等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;深层网络爬虫（Deep Web Crawler）&lt;/strong&gt;：指大部分内容不能通过静态链接获取，只有用户提交一些表单信息才能获取的 Web 页面。例如，需要模拟登陆的网络爬虫便属于这类网络爬虫。另外，还有一些需要用户提交关键词才能获取的内容，如京东淘宝提交关键字、价格区间获取产品的相关信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;而实际上，网络爬虫系统通常是几种爬虫技术相结合实现的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络爬虫的流程&quot;&gt;&lt;a href=&quot;#网络爬虫的流程&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫的流程&quot;&gt;&lt;/a&gt;网络爬虫的流程&lt;/h2&gt;&lt;p&gt;网络爬虫基本流程可用下图描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/13/Java爬虫/爬虫的基本流程图.png&quot; alt=&quot;爬虫基本流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求者选取一部分种子 URL（或初始 URL），将其放入待爬取的队列中。如在 Java 网络爬虫中，可以放入 LinkedList 或 List 中。&lt;/li&gt;
&lt;li&gt;判断 URL 队列是否为空，如果为空则结束程序的执行，否则执行第三步骤。&lt;/li&gt;
&lt;li&gt;从待爬取的 URL 队列中取出待爬的一个 URL，获取 URL 对应的网页内容。在此步骤需要使用响应的状态码（如200，403等）判断是否获取数据，如响应成功则执行解析操作；如响应不成功，则将其重新放入待爬取队列（注意这里需要移除无效 URL)。&lt;/li&gt;
&lt;li&gt;针对已经响应成功后获取到的数据，执行页面解析操作。此步骤根据用户需求获取网页内容里的部分数据，如汽车论坛帖子的标题、发表的时间等。&lt;/li&gt;
&lt;li&gt;针对3步骤已解析的数据，将其进行存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;爬行策略-算法&quot;&gt;&lt;a href=&quot;#爬行策略-算法&quot; class=&quot;headerlink&quot; title=&quot;爬行策略(算法)&quot;&gt;&lt;/a&gt;爬行策略(算法)&lt;/h2&gt;&lt;p&gt;一般的网络爬虫的爬行策略分为两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索（Depth-First Search）策略&lt;/strong&gt;：从根节点的 URL 开始，根据优先级向下遍历该根节点对应的子节点。当访问到某一子节点 URL 时，以该子节点为入口，继续向下层遍历，直到没有新的子节点可以继续访问为止。接着使用回溯的方法，找到没有被访问到的节点，以类似的方式进行搜索。&lt;br&gt;从种子页到当前页的打开连接数，一般建议不要超过5层。&lt;br&gt;深度优先示意图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/2019/07/13/Java爬虫/深度优先.png&quot; alt=&quot;深度优先示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广度优先搜索（Breadth-First Search）策略&lt;/strong&gt;：也称为宽度优先，是另外一种非常有效的搜索技术，这种方法按照按深度的层级来进行页面的遍历。&lt;br&gt;深度优先示意图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/2019/07/13/Java爬虫/广度优先.png&quot; alt=&quot;广度优先示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上两者也就是深度优先算法和广度优先算法的实际应用。而基于广度优先的爬虫是最简单的爬取网站页面的方法，也是目前使用较为广泛的方法。&lt;/p&gt;
&lt;h2 id=&quot;话不多说，先放一下初步学习一天的成果&quot;&gt;&lt;a href=&quot;#话不多说，先放一下初步学习一天的成果&quot; class=&quot;headerlink&quot; title=&quot;话不多说，先放一下初步学习一天的成果&quot;&gt;&lt;/a&gt;话不多说，先放一下初步学习一天的成果&lt;/h2&gt;&lt;p&gt;对仁慈的京东进行初步、少量(一页)的数据爬取&lt;br&gt;流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入京东首页，搜索框中随便输入一个商品名进行搜索(本人选择的是手机)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/13/Java爬虫/京东首页搜索商品.png&quot; alt=&quot;京东首页搜索商品图&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;F12打开开发者工具栏，找到页面中商品列表&lt;strong&gt;标签&lt;/strong&gt;所在位置，并分析其位置关系，定位爬取信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;定位商品信息标签的父节点标签id为：J_goodsList&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/13/Java爬虫/定位商品信息标签的父节点.png&quot; alt=&quot;定位商品信息标签的父节点&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位商品信息所在的li标签，选择合适的定位方法(这里选择了li中的class属性: .gl-item)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/13/Java爬虫/定位商品信息所在的li标签.png&quot; alt=&quot;定位商品信息所在的li标签&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过商品所在的li标签中的子元素，便可获取商品的所有信息了(有空再细讲吧，先上个图意思意思)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/13/Java爬虫/li标签中的子元素.png&quot; alt=&quot;商品信息所在的li标签中的子元素&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性&quot;&gt;&lt;a href=&quot;#说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性&quot; class=&quot;headerlink&quot; title=&quot;说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性&quot;&gt;&lt;/a&gt;说到爬商品数据，就不得不提到SPU、SKU这两个重要的商品属性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SPU：Standard product Unit(标准产品单位) 品种名&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;SKU：Stok Keeping Unit(最小库存量单位) 规格类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说，一个spu对应一个商品；而一个商品可以对应多个sku，因为sku指的是商品的规格。&lt;br&gt;举例：&lt;br&gt;小米8手机假设它的spu为： 1239。那么这个1239就代表了小米8这款手机，而这款手机它会有不同的颜色款式，甚至会有配置的变化(如运存大小，处理器型号)。这时就以sku来做区分。&lt;br&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红色的小米8，处理器是骁龙880，价格为3444元，sku为1239(与spu一致，作为默认主图显示的款式)&lt;/li&gt;
&lt;li&gt;红色的小米8，处理器是骁龙760，价格为2444元，sku为1233(与spu不一致，也不同于前者的sku，在缩略图显示的款式)&lt;/li&gt;
&lt;li&gt;蓝色的小米8，处理器是骁龙860，价格为3222元，sku为1244(与spu不一致，也不同于前者的sku，在缩略图显示的款式)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java 爬虫" scheme="http://seasontemple.top/tags/Java-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="http://seasontemple.top/2019/07/01/Maven/"/>
    <id>http://seasontemple.top/2019/07/01/Maven/</id>
    <published>2019-07-01T12:48:45.000Z</published>
    <updated>2019-07-13T05:32:41.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天来谈谈Maven"><a href="#今天来谈谈Maven" class="headerlink" title="今天来谈谈Maven"></a>今天来谈谈Maven</h1><p><a href="http://maven.apache.org" target="_blank" rel="noopener"><img src="/2019/07/01/Maven/Maven-Log.png" alt="Maven Log"></a></p><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><p>Maven——全称Apache Maven，是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。<br>Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。</p><p>也就是说，Maven是一个：</p><ul><li>构建工具：从源码到成品</li><li>依赖管理工具：通过pom.xml来管理项目中的jar包依赖</li><li>项目信息聚合工具：保持项目信息的一致性——使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。</li></ul><h2 id="Maven的目标"><a href="#Maven的目标" class="headerlink" title="Maven的目标"></a>Maven的目标</h2><p>Maven的主要目标是让开发人员在最短的时间内理解开发工作的完整状态。为了实现这一目标，Maven试图处理以下几个方面的问题：    </p><ul><li>使构建过程变得简单</li><li>提供统一的构建系统</li><li>提供优质的项目信息</li><li>提供最佳实践开发指南</li><li>允许透明迁移到新功能</li></ul><h2 id="Maven的主要特点"><a href="#Maven的主要特点" class="headerlink" title="Maven的主要特点"></a>Maven的主要特点</h2><ul><li>遵循最佳实践的简单项目设置 - 在几秒钟内启动新项目或模块</li><li>所有项目的一致使用 - 意味着新开发人员进入项目的时间不会增加</li><li>卓越的依赖管理，包括自动更新，依赖关闭（也称为传递依赖）</li><li>能够轻松地同时处理多个项目</li><li>一个庞大且不断增长的库和元数据库，可以立即使用，并与最大的开源项目安排实时可用的最新版本</li><li>可扩展，能够轻松编写 Java或脚本语言的插件</li><li>只需很少或不需要额外配置即可立即访问新功能</li><li>用于在Maven之外进行依赖关系管理和部署的Ant任务</li><li>基于模型的构建：Maven能够根据项目的元数据将任意数量的项目构建到预定义的输出类型（如JAR，WAR或分发）中，而无需在大多数情况下执行任何脚本编写。</li><li>项目信息的连贯性站点：使用与构建过程相同的元数据，Maven能够生成包含您需要添加的任何文档的网站或PDF，并添加有关项目开发状态的标准报告。在“项目信息”和“项目报告”子菜单下，可以在本网站左侧导航栏的底部看到此信息的示例。**</li><li>发布管理和发布发布：没有太多额外配置，Maven将与您的源代码控制系统（如Subversion或Git）集成，并根据特定标记管理项目的发布。它还可以将其发布到分发位置以供其他项目使用。Maven能够发布单个输出，例如JAR，包含其他依赖关系和文档的存档，或者作为源分发。</li><li>依赖管理：Maven鼓励使用JAR和其他依赖项的中央存储库。Maven附带了一种机制，您的项目客户可以使用该机制从中央JAR存储库下载构建项目所需的任何JAR，就像Perl的CPAN一样。这允许Maven的用户跨项目重用JAR并鼓励项目之间的通信，以确保处理向后兼容性问题。</li></ul><h2 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h2><ul><li>maven对构建(build)的过程进行了抽象和定义，这个过程被称为构建的生命周期(lifecycle)。</li><li>生命周期(lifecycle)由多个阶段(phase)组成,每个阶段(phase)会挂接一到多个goal。</li><li>goal是maven里定义任务的最小单元，相当于ant里的target。</li><li>可以理解maven为一个插件的容器,每个插件绑定到某个goal执行</li></ul><h3 id="典型的构建生命周期"><a href="#典型的构建生命周期" class="headerlink" title="典型的构建生命周期"></a>典型的构建生命周期</h3><p>Maven 构建生命周期定义了一个项目构建跟发布的过程。<br>一个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：<br>start-&gt;validate-&gt;compile-&gt;test-&gt;package-&gt;verify-&gt;install-&gt;deploy-&gt;end</p><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">处理</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">验证 validate</td><td style="text-align:left">验证项目</td><td style="text-align:left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:left">编译 compile</td><td style="text-align:left">执行编译</td><td style="text-align:left">源代码编译在此阶段完成</td></tr><tr><td style="text-align:left">测试 Test</td><td style="text-align:left">测试</td><td style="text-align:left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left">包装 package</td><td style="text-align:left">打包</td><td style="text-align:left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td style="text-align:left">检查 verify</td><td style="text-align:left">检查</td><td style="text-align:left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:left">安装 install</td><td style="text-align:left">安装</td><td style="text-align:left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:left">部署 deploy</td><td style="text-align:left">部署</td><td style="text-align:left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><p><strong>为了完成该生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。</strong><br>Maven 有以下三个<strong>相互独立</strong>的标准的生命周期：</p><ul><li><strong>clean</strong>：项目清理的处理</li><li><strong>default(或 build)</strong>：项目部署的处理</li><li><strong>site</strong>：项目站点文档创建的处理</li></ul><h3 id="Clean生命周期"><a href="#Clean生命周期" class="headerlink" title="Clean生命周期"></a>Clean生命周期</h3><p>当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：</p><ul><li><strong>pre-clean</strong>：执行一些需要在clean之前完成的工作</li><li><strong>clean</strong>：移除所有上一次构建生成的文件</li><li><strong>post-clean</strong>：执行一些需要在clean之后立刻完成的工作</li></ul><p><strong>注意：在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行。</strong></p><h3 id="Default-Build-生命周期"><a href="#Default-Build-生命周期" class="headerlink" title="Default(Build)生命周期"></a>Default(Build)生命周期</h3><p>这是 Maven 的主要生命周期，被用于构建应用，包括下面的 23 个阶段：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">生命周期阶段</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">validate</td><td style="text-align:left">检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">initialize</td><td style="text-align:left">初始化构建状态，例如设置属性。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">generate-sources</td><td style="text-align:left">生成编译阶段需要包含的任何源码文件。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">process-sources</td><td style="text-align:left">处理源代码，例如，过滤任何值（filter any value）。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">generate-resources</td><td style="text-align:left">生成工程包中需要包含的资源文件。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">process-resources</td><td style="text-align:left">拷贝和处理资源文件到目的目录中，为打包阶段做准备。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">compile</td><td style="text-align:left">编译工程源码。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">process-classes</td><td style="text-align:left">处理编译生成的文件，例如 Java Class 字节码的加强和优化。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">generate-test-sources</td><td style="text-align:left">生成编译阶段需要包含的任何测试源代码。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">process-test-sources</td><td style="text-align:left">处理测试源代码，例如，过滤任何值（filter any values）。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">generate-test-resources</td><td style="text-align:left">允许生成与测试相关的(非源码)资源。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">process-test-resources</td><td style="text-align:left">可以处理、转换和重新定位与测试相关的资源。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">test-compile</td><td style="text-align:left">编译测试源代码到测试目的目录。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">process-test-classes</td><td style="text-align:left">处理测试代码文件编译后生成的文件。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">test</td><td style="text-align:left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">prepare-package</td><td style="text-align:left">在真正打包之前，为准备打包执行任何必要的操作。</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">package</td><td style="text-align:left">获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">pre-integration-test</td><td style="text-align:left">在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left">integration-test</td><td style="text-align:left">处理和部署必须的工程包到集成测试能够运行的环境中。</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left">post-integration-test</td><td style="text-align:left">在集成测试被执行后执行必要的操作。例如，清理环境。</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left">verify</td><td style="text-align:left">运行检查操作来验证工程包是有效的，并满足质量要求。</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left">install</td><td style="text-align:left">安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left">deploy</td><td style="text-align:left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。</td></tr></tbody></table><p>也可以用图表示：</p><p><img src="/2019/07/01/Maven/lifecycle.png" alt="lifecycle"></p><p><strong>与 Maven 生命周期相关的重要概念需要说明：</strong></p><ul><li><strong>当一个阶段通过 Maven 命令调用时，例如 mvn compile，只有该阶段之前以及包括该阶段在内的所有阶段会被执行。</strong></li><li><strong>不同的 maven 目标将根据打包的类型（JAR / WAR / EAR），被绑定到不同的 Maven 生命周期阶段。</strong></li></ul><h3 id="Site周期"><a href="#Site周期" class="headerlink" title="Site周期"></a>Site周期</h3><p>Maven Site 插件一般用来创建新的报告文档、部署站点等。<br>包括下面的4个阶段：</p><table><thead><tr><th style="text-align:left">生命周期阶段</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pre-site</td><td style="text-align:left">执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td style="text-align:left">site</td><td style="text-align:left">生成项目的站点文档</td></tr><tr><td style="text-align:left">post-site</td><td style="text-align:left">执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</td></tr><tr><td style="text-align:left">site-deploy</td><td style="text-align:left">将生成的站点文档部署到特定的服务器上</td></tr></tbody></table><p><strong>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。 在下面的例子中，我们将 maven-antrun-plugin:run 目标添加到 Site 生命周期的所有阶段中。这样我们可以显示生命周期的所有文本信息。</strong></p><h2 id="Maven的坐标"><a href="#Maven的坐标" class="headerlink" title="Maven的坐标"></a>Maven的坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;json-lib&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;/type&gt;</span><br><span class="line">&lt;classifier&gt;jdk15&lt;/classifier&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>俗称 gav：使用下面三个向量子仓库中唯一定位一个 Maven 工程<br>在项目中的 pom.xml 文件中，我们可以看到下面gav的定义：</p><ol><li><strong>groupid</strong>：公司或组织域名倒序<br> <em>&lt;groupid&gt;com.ys.maven&lt;/groupid&gt;</em></li><li><strong>artifactid</strong>：模块名，也是实际项目的名称<br> <em>&lt;artifactid&gt;Maven_05&lt;/artifactid&gt;</em></li><li><strong>version</strong>：当前项目的版本<br> <em>&lt;version&gt;.0.1-SNAPSHOT&lt;/version&gt;</em></li></ol><h3 id="Maven-坐标和仓库，jar-包的关系"><a href="#Maven-坐标和仓库，jar-包的关系" class="headerlink" title="Maven 坐标和仓库，jar 包的关系"></a>Maven 坐标和仓库，jar 包的关系</h3><p>什么是仓库，是用来<strong>统一</strong>存放 jar 包的地方。<br>将上面配置的 gav 向量组合起来就是安装目录：<br>&emsp;<strong>com/ys/maven/Maven_05/0.0.1-SNAPSHOT/Maven_05-0.0.1-SNAPSHOT.jar</strong><br>而 jar 包为：<br>&emsp;<strong>Maven_05-0.0.1-SNAPSHOT.jar</strong><br>也就是：<br>&emsp;<strong>artifactid-version.jar</strong></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>什么是 依赖？相信有过一定开发经验的人知道，每当我们需要使用某个框架时，比如 SpringMVC，那么我们需要导入相应的 jar 包，但是手动导入包的时候，往往会漏掉几个 jar 包，那么在使用该框架的时候系统就会报错。那么就说导入的包与未导入的包存在依赖关系。而使用 Maven,我们只需要在 pom.xml 文件中进行相应的配置，它就会帮助我们自动管理 jar 包之间的依赖关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;     </span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;     </span><br><span class="line">        &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;...&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;...&lt;/scope&gt;</span><br><span class="line">        &lt;optional&gt;...&lt;/optional&gt;</span><br><span class="line">        &lt;exclusions&gt;     </span><br><span class="line">            &lt;exclusion&gt;     </span><br><span class="line">              &lt;groupId&gt;...&lt;/groupId&gt;     </span><br><span class="line">              &lt;artifactId&gt;...&lt;/artifactId&gt;     </span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">      &lt;/exclusions&gt;     </span><br><span class="line">    &lt;/dependency&gt;        </span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">作用描述</th></tr></thead><tbody><tr><td style="text-align:left">dependencies</td><td style="text-align:left">一个 pom.xml 文件中只能存在一个这样的标签。用来管理依赖的总标签。</td></tr><tr><td style="text-align:left">dependency</td><td style="text-align:left">包含在dependencies标签中，可以有无数个，每一个表示一个依赖</td></tr><tr><td style="text-align:left">groupId<br>artifactId<br>version</td><td style="text-align:left">依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</td></tr><tr><td style="text-align:left">type</td><td style="text-align:left">依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值是jar。</td></tr><tr><td style="text-align:left">scope</td><td style="text-align:left">依赖的范围，默认值是 compile。</td></tr><tr><td style="text-align:left">optional</td><td style="text-align:left">标记依赖是否可选。</td></tr><tr><td style="text-align:left">exclusions</td><td style="text-align:left">用来排除传递性依赖。</td></tr></tbody></table><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><table><thead><tr><th style="text-align:left">依赖范围（scope）</th><th style="text-align:left">编译时依赖</th><th style="text-align:left">测试时依赖</th><th style="text-align:left">运行时依赖</th><th style="text-align:left">是否打入包</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">compile</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">SLF4J</td></tr><tr><td style="text-align:left">provided</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">SERVLET-API</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">N</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">N</td><td style="text-align:left">JUNIT</td></tr><tr><td style="text-align:left">runtime</td><td style="text-align:left">N</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">MYSQL JDBC DRIVER</td></tr><tr><td style="text-align:left">system</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">Y</td><td style="text-align:left">有nexus后,不用system</td></tr></tbody></table><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p><strong>注意：只有编译和运行时依赖可以传递</strong><br>例：<br>&emsp;A-&gt;B-&gt;C</p><ul><li>简单传递依赖:A-&gt;C<br>&emsp;A-&gt;B-C(0.1)<br>&emsp;A-&gt;C(0.2)</li><li>最短路径优先原则: A-&gt;C(0.2)<br>&emsp;A-&gt;B-&gt;C(0.1)<br>&emsp;A-&gt;E-&gt;C(0.2)</li><li>第一声明优先原则:最终依赖C(0.1)</li></ul><h3 id="依赖归类"><a href="#依赖归类" class="headerlink" title="依赖归类"></a>依赖归类</h3><h3 id="依赖排除"><a href="#依赖排除" class="headerlink" title="依赖排除"></a>依赖排除</h3><h3 id="依赖继承"><a href="#依赖继承" class="headerlink" title="依赖继承"></a>依赖继承</h3><p>###Maven依赖查找顺序<br><strong>本地仓库-&gt;镜像库(阿里)-&gt;中央仓库</strong></p><h2 id="剩下的部分有空再改"><a href="#剩下的部分有空再改" class="headerlink" title="剩下的部分有空再改"></a>剩下的部分有空再改</h2><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天来谈谈Maven&quot;&gt;&lt;a href=&quot;#今天来谈谈Maven&quot; class=&quot;headerlink&quot; title=&quot;今天来谈谈Maven&quot;&gt;&lt;/a&gt;今天来谈谈Maven&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://maven.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;/2019/07/01/Maven/Maven-Log.png&quot; alt=&quot;Maven Log&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Maven是什么&quot;&gt;&lt;a href=&quot;#Maven是什么&quot; class=&quot;headerlink&quot; title=&quot;Maven是什么&quot;&gt;&lt;/a&gt;Maven是什么&lt;/h2&gt;&lt;p&gt;Maven——全称Apache Maven，是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。&lt;br&gt;Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。&lt;/p&gt;
&lt;p&gt;也就是说，Maven是一个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建工具：从源码到成品&lt;/li&gt;
&lt;li&gt;依赖管理工具：通过pom.xml来管理项目中的jar包依赖&lt;/li&gt;
&lt;li&gt;项目信息聚合工具：保持项目信息的一致性——使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Maven的目标&quot;&gt;&lt;a href=&quot;#Maven的目标&quot; class=&quot;headerlink&quot; title=&quot;Maven的目标&quot;&gt;&lt;/a&gt;Maven的目标&lt;/h2&gt;&lt;p&gt;Maven的主要目标是让开发人员在最短的时间内理解开发工作的完整状态。为了实现这一目标，Maven试图处理以下几个方面的问题：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使构建过程变得简单&lt;/li&gt;
&lt;li&gt;提供统一的构建系统&lt;/li&gt;
&lt;li&gt;提供优质的项目信息&lt;/li&gt;
&lt;li&gt;提供最佳实践开发指南&lt;/li&gt;
&lt;li&gt;允许透明迁移到新功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Maven的主要特点&quot;&gt;&lt;a href=&quot;#Maven的主要特点&quot; class=&quot;headerlink&quot; title=&quot;Maven的主要特点&quot;&gt;&lt;/a&gt;Maven的主要特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;遵循最佳实践的简单项目设置 - 在几秒钟内启动新项目或模块&lt;/li&gt;
&lt;li&gt;所有项目的一致使用 - 意味着新开发人员进入项目的时间不会增加&lt;/li&gt;
&lt;li&gt;卓越的依赖管理，包括自动更新，依赖关闭（也称为传递依赖）&lt;/li&gt;
&lt;li&gt;能够轻松地同时处理多个项目&lt;/li&gt;
&lt;li&gt;一个庞大且不断增长的库和元数据库，可以立即使用，并与最大的开源项目安排实时可用的最新版本&lt;/li&gt;
&lt;li&gt;可扩展，能够轻松编写 Java或脚本语言的插件&lt;/li&gt;
&lt;li&gt;只需很少或不需要额外配置即可立即访问新功能&lt;/li&gt;
&lt;li&gt;用于在Maven之外进行依赖关系管理和部署的Ant任务&lt;/li&gt;
&lt;li&gt;基于模型的构建：Maven能够根据项目的元数据将任意数量的项目构建到预定义的输出类型（如JAR，WAR或分发）中，而无需在大多数情况下执行任何脚本编写。&lt;/li&gt;
&lt;li&gt;项目信息的连贯性站点：使用与构建过程相同的元数据，Maven能够生成包含您需要添加的任何文档的网站或PDF，并添加有关项目开发状态的标准报告。在“项目信息”和“项目报告”子菜单下，可以在本网站左侧导航栏的底部看到此信息的示例。**&lt;/li&gt;
&lt;li&gt;发布管理和发布发布：没有太多额外配置，Maven将与您的源代码控制系统（如Subversion或Git）集成，并根据特定标记管理项目的发布。它还可以将其发布到分发位置以供其他项目使用。Maven能够发布单个输出，例如JAR，包含其他依赖关系和文档的存档，或者作为源分发。&lt;/li&gt;
&lt;li&gt;依赖管理：Maven鼓励使用JAR和其他依赖项的中央存储库。Maven附带了一种机制，您的项目客户可以使用该机制从中央JAR存储库下载构建项目所需的任何JAR，就像Perl的CPAN一样。这允许Maven的用户跨项目重用JAR并鼓励项目之间的通信，以确保处理向后兼容性问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Maven的生命周期&quot;&gt;&lt;a href=&quot;#Maven的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Maven的生命周期&quot;&gt;&lt;/a&gt;Maven的生命周期&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;maven对构建(build)的过程进行了抽象和定义，这个过程被称为构建的生命周期(lifecycle)。&lt;/li&gt;
&lt;li&gt;生命周期(lifecycle)由多个阶段(phase)组成,每个阶段(phase)会挂接一到多个goal。&lt;/li&gt;
&lt;li&gt;goal是maven里定义任务的最小单元，相当于ant里的target。&lt;/li&gt;
&lt;li&gt;可以理解maven为一个插件的容器,每个插件绑定到某个goal执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;典型的构建生命周期&quot;&gt;&lt;a href=&quot;#典型的构建生命周期&quot; class=&quot;headerlink&quot; title=&quot;典型的构建生命周期&quot;&gt;&lt;/a&gt;典型的构建生命周期&lt;/h3&gt;&lt;p&gt;Maven 构建生命周期定义了一个项目构建跟发布的过程。&lt;br&gt;一个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：&lt;br&gt;start-&amp;gt;validate-&amp;gt;compile-&amp;gt;test-&amp;gt;package-&amp;gt;verify-&amp;gt;install-&amp;gt;deploy-&amp;gt;end&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;阶段&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;处理&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;验证 validate&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;验证项目&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;验证项目是否正确且所有必须信息是可用的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编译 compile&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;执行编译&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;源代码编译在此阶段完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;测试 Test&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;测试&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;使用适当的单元测试框架（例如JUnit）运行测试。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包装 package&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;打包&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;创建JAR/WAR包如在 pom.xml 中定义提及的包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;检查 verify&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;检查&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;对集成测试的结果进行检查，以保证质量达标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安装 install&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安装&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安装打包的项目到本地仓库，以供其他项目使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;部署 deploy&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;部署&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;为了完成该生命周期，这些阶段（包括其他未在上面罗列的生命周期阶段）将被按顺序地执行。&lt;/strong&gt;&lt;br&gt;Maven 有以下三个&lt;strong&gt;相互独立&lt;/strong&gt;的标准的生命周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;clean&lt;/strong&gt;：项目清理的处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default(或 build)&lt;/strong&gt;：项目部署的处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;site&lt;/strong&gt;：项目站点文档创建的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Clean生命周期&quot;&gt;&lt;a href=&quot;#Clean生命周期&quot; class=&quot;headerlink&quot; title=&quot;Clean生命周期&quot;&gt;&lt;/a&gt;Clean生命周期&lt;/h3&gt;&lt;p&gt;当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pre-clean&lt;/strong&gt;：执行一些需要在clean之前完成的工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clean&lt;/strong&gt;：移除所有上一次构建生成的文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;post-clean&lt;/strong&gt;：执行一些需要在clean之后立刻完成的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Default-Build-生命周期&quot;&gt;&lt;a href=&quot;#Default-Build-生命周期&quot; class=&quot;headerlink&quot; title=&quot;Default(Build)生命周期&quot;&gt;&lt;/a&gt;Default(Build)生命周期&lt;/h3&gt;&lt;p&gt;这是 Maven 的主要生命周期，被用于构建应用，包括下面的 23 个阶段：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;生命周期阶段&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;validate&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;initialize&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;初始化构建状态，例如设置属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;generate-sources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;生成编译阶段需要包含的任何源码文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;process-sources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;处理源代码，例如，过滤任何值（filter any value）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;5&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;generate-resources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;生成工程包中需要包含的资源文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;6&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;process-resources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;拷贝和处理资源文件到目的目录中，为打包阶段做准备。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;7&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;compile&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编译工程源码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;process-classes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;处理编译生成的文件，例如 Java Class 字节码的加强和优化。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;9&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;generate-test-sources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;生成编译阶段需要包含的任何测试源代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;process-test-sources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;处理测试源代码，例如，过滤任何值（filter any values）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;11&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;generate-test-resources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;允许生成与测试相关的(非源码)资源。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;12&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;process-test-resources&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可以处理、转换和重新定位与测试相关的资源。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;13&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;test-compile&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;编译测试源代码到测试目的目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;14&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;process-test-classes&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;处理测试代码文件编译后生成的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;test&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;使用适当的单元测试框架（例如JUnit）运行测试。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;16&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;prepare-package&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在真正打包之前，为准备打包执行任何必要的操作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;17&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;package&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;18&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;pre-integration-test&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;19&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;integration-test&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;处理和部署必须的工程包到集成测试能够运行的环境中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;20&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;post-integration-test&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在集成测试被执行后执行必要的操作。例如，清理环境。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;21&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;verify&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;运行检查操作来验证工程包是有效的，并满足质量要求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;22&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;install&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;23&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;deploy&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;也可以用图表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/01/Maven/lifecycle.png&quot; alt=&quot;lifecycle&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与 Maven 生命周期相关的重要概念需要说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当一个阶段通过 Maven 命令调用时，例如 mvn compile，只有该阶段之前以及包括该阶段在内的所有阶段会被执行。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同的 maven 目标将根据打包的类型（JAR / WAR / EAR），被绑定到不同的 Maven 生命周期阶段。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Site周期&quot;&gt;&lt;a href=&quot;#Site周期&quot; class=&quot;headerlink&quot; title=&quot;Site周期&quot;&gt;&lt;/a&gt;Site周期&lt;/h3&gt;&lt;p&gt;Maven Site 插件一般用来创建新的报告文档、部署站点等。&lt;br&gt;包括下面的4个阶段：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;生命周期阶段&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;pre-site&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;执行一些需要在生成站点文档之前完成的工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;site&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;生成项目的站点文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;post-site&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;执行一些需要在生成站点文档之后完成的工作，并且为部署做准备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;site-deploy&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;将生成的站点文档部署到特定的服务器上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。 在下面的例子中，我们将 maven-antrun-plugin:run 目标添加到 Site 生命周期的所有阶段中。这样我们可以显示生命周期的所有文本信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Maven的坐标&quot;&gt;&lt;a href=&quot;#Maven的坐标&quot; class=&quot;headerlink&quot; title=&quot;Maven的坐标&quot;&gt;&lt;/a&gt;Maven的坐标&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;net.sf.json-lib&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;json-lib&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;classifier&amp;gt;jdk15&amp;lt;/classifier&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;俗称 gav：使用下面三个向量子仓库中唯一定位一个 Maven 工程&lt;br&gt;在项目中的 pom.xml 文件中，我们可以看到下面gav的定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;groupid&lt;/strong&gt;：公司或组织域名倒序&lt;br&gt; &lt;em&gt;&amp;lt;groupid&amp;gt;com.ys.maven&amp;lt;/groupid&amp;gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;artifactid&lt;/strong&gt;：模块名，也是实际项目的名称&lt;br&gt; &lt;em&gt;&amp;lt;artifactid&amp;gt;Maven_05&amp;lt;/artifactid&amp;gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;：当前项目的版本&lt;br&gt; &lt;em&gt;&amp;lt;version&amp;gt;.0.1-SNAPSHOT&amp;lt;/version&amp;gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Maven-坐标和仓库，jar-包的关系&quot;&gt;&lt;a href=&quot;#Maven-坐标和仓库，jar-包的关系&quot; class=&quot;headerlink&quot; title=&quot;Maven 坐标和仓库，jar 包的关系&quot;&gt;&lt;/a&gt;Maven 坐标和仓库，jar 包的关系&lt;/h3&gt;&lt;p&gt;什么是仓库，是用来&lt;strong&gt;统一&lt;/strong&gt;存放 jar 包的地方。&lt;br&gt;将上面配置的 gav 向量组合起来就是安装目录：&lt;br&gt;&amp;emsp;&lt;strong&gt;com/ys/maven/Maven_05/0.0.1-SNAPSHOT/Maven_05-0.0.1-SNAPSHOT.jar&lt;/strong&gt;&lt;br&gt;而 jar 包为：&lt;br&gt;&amp;emsp;&lt;strong&gt;Maven_05-0.0.1-SNAPSHOT.jar&lt;/strong&gt;&lt;br&gt;也就是：&lt;br&gt;&amp;emsp;&lt;strong&gt;artifactid-version.jar&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h2&gt;&lt;p&gt;什么是 依赖？相信有过一定开发经验的人知道，每当我们需要使用某个框架时，比如 SpringMVC，那么我们需要导入相应的 jar 包，但是手动导入包的时候，往往会漏掉几个 jar 包，那么在使用该框架的时候系统就会报错。那么就说导入的包与未导入的包存在依赖关系。而使用 Maven,我们只需要在 pom.xml 文件中进行相应的配置，它就会帮助我们自动管理 jar 包之间的依赖关系。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;type&amp;gt;...&amp;lt;/type&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;scope&amp;gt;...&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;optional&amp;gt;...&amp;lt;/optional&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;exclusions&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;exclusion&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;lt;groupId&amp;gt;...&amp;lt;/groupId&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;lt;artifactId&amp;gt;...&amp;lt;/artifactId&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;/exclusion&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      	&amp;lt;/exclusions&amp;gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/dependency&amp;gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;名称&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;作用描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dependencies&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;一个 pom.xml 文件中只能存在一个这样的标签。用来管理依赖的总标签。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;dependency&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包含在dependencies标签中，可以有无数个，每一个表示一个依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;groupId&lt;br&gt;artifactId&lt;br&gt;version&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;type&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值是jar。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;scope&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;依赖的范围，默认值是 compile。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;optional&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;标记依赖是否可选。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;exclusions&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;用来排除传递性依赖。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;依赖范围&quot;&gt;&lt;a href=&quot;#依赖范围&quot; class=&quot;headerlink&quot; title=&quot;依赖范围&quot;&gt;&lt;/a&gt;依赖范围&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;依赖范围（scope）&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;编译时依赖&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;测试时依赖&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;运行时依赖&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;是否打入包&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;compile&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;SLF4J&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;provided&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;SERVLET-API&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;test&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;JUNIT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;runtime&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;N&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;MYSQL JDBC DRIVER&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;system&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;有nexus后,不用system&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;依赖传递&quot;&gt;&lt;a href=&quot;#依赖传递&quot; class=&quot;headerlink&quot; title=&quot;依赖传递&quot;&gt;&lt;/a&gt;依赖传递&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;注意：只有编译和运行时依赖可以传递&lt;/strong&gt;&lt;br&gt;例：&lt;br&gt;&amp;emsp;A-&amp;gt;B-&amp;gt;C&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单传递依赖:A-&amp;gt;C&lt;br&gt;&amp;emsp;A-&amp;gt;B-C(0.1)&lt;br&gt;&amp;emsp;A-&amp;gt;C(0.2)&lt;/li&gt;
&lt;li&gt;最短路径优先原则: A-&amp;gt;C(0.2)&lt;br&gt;&amp;emsp;A-&amp;gt;B-&amp;gt;C(0.1)&lt;br&gt;&amp;emsp;A-&amp;gt;E-&amp;gt;C(0.2)&lt;/li&gt;
&lt;li&gt;第一声明优先原则:最终依赖C(0.1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;依赖归类&quot;&gt;&lt;a href=&quot;#依赖归类&quot; class=&quot;headerlink&quot; title=&quot;依赖归类&quot;&gt;&lt;/a&gt;依赖归类&lt;/h3&gt;&lt;h3 id=&quot;依赖排除&quot;&gt;&lt;a href=&quot;#依赖排除&quot; class=&quot;headerlink&quot; title=&quot;依赖排除&quot;&gt;&lt;/a&gt;依赖排除&lt;/h3&gt;&lt;h3 id=&quot;依赖继承&quot;&gt;&lt;a href=&quot;#依赖继承&quot; class=&quot;headerlink&quot; title=&quot;依赖继承&quot;&gt;&lt;/a&gt;依赖继承&lt;/h3&gt;&lt;p&gt;###Maven依赖查找顺序&lt;br&gt;&lt;strong&gt;本地仓库-&amp;gt;镜像库(阿里)-&amp;gt;中央仓库&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;剩下的部分有空再改&quot;&gt;&lt;a href=&quot;#剩下的部分有空再改&quot; class=&quot;headerlink&quot; title=&quot;剩下的部分有空再改&quot;&gt;&lt;/a&gt;剩下的部分有空再改&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Something about Maven" scheme="http://seasontemple.top/tags/Something-about-Maven/"/>
    
  </entry>
  
  <entry>
    <title>杂谈--Java与JVM</title>
    <link href="http://seasontemple.top/2019/06/11/%E6%9D%82%E8%AE%BA-Java%E4%B8%8EJVM/"/>
    <id>http://seasontemple.top/2019/06/11/杂论-Java与JVM/</id>
    <published>2019-06-11T11:44:16.000Z</published>
    <updated>2019-09-26T10:18:24.075Z</updated>
    
    <content type="html"><![CDATA[<p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p><meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>尽管一直在学java、用java，但对于底层的东西却仍处于一知半解的状态。<br>显然这样下去是不行的，如果只为了敲代码而敲代码。可以预见今后的工作中只会陷入一种死循环–敲代码、出Bug、改Bug、改不好、重新敲、出Bug，然后改、改不好，最后就只能是改不动自闭、改不动自闭and改不动自闭。  </p><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>在了解Java的机制之前，需要先了解类在JVM（Java虚拟机）中是如何加载的，这对后面理解java其它机制将有重要作用。</p><p>每个类编译后产生一个Class对象，存储在.class文件中，JVM使用类加载器（Class Loader）来加载类的字节码文件（.class），类加载器实质上是一条类加载器链，一般的，我们只会用到一个原生的类加载器，它只加载Java API等可信类，通常只是在本地磁盘中加载，这些类一般就够我们使用了。如果我们需要从远程网络或数据库中下载.class字节码文件，那就需要我们来挂载额外的类加载器。</p><p>一般来说，类加载器是按照树形的层次结构组织的，每个加载器都有一个父类加载器。另外，每个类加载器都支持代理模式，即可以自己完成Java类的加载工作，也可以代理给其它类加载器。</p><p>类加载器的加载顺序有两种，一种是父类优先策略，一种是是自己优先策略，父类优先策略是比较一般的情况（如JDK采用的就是这种方式），在这种策略下，类在加载某个Java类之前，会尝试代理给其父类加载器，只有当父类加载器找不到时，才尝试自己去加载。自己优先的策略与父类优先相反，它会首先尝试自己加载，找不到的时候才要父类加载器去加载，这种在web容器（如tomcat）中比较常见。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：<br>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载    </p><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>不管使用什么样的类加载器，类，都是在第一次被用到时，动态加载到JVM的。这句话有两层含义：</p><ul><li>Java程序在运行时并不一定被完整加载，只有当发现该类还没有加载时，才去本地或远程查找类的.class文件并验证和加载；</li><li>当程序创建了第一个对类的静态成员的引用（如类的静态变量、静态方法、构造方法——构造方法也是静态的）时，才会加载该类。Java的这个特性叫做：动态加载。</li></ul><p>需要区分加载和初始化的区别，加载了一个类的.class文件，不以为着该Class对象被初始化，事实上，一个类的初始化包括3个步骤：</p><ul><li>加载（Loading），由类加载器执行，查找字节码，并创建一个Class对象（只是创建）；</li><li>链接（Linking），验证字节码，为静态域分配存储空间（只是分配，并不初始化该存储空间），解析该类创建所需要的对其它类的应用；</li></ul><p>初始化（Initialization），首先执行静态初始化块static{}，初始化静态变量，执行静态方法（如构造方法）。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Java在加载了类之后，需要进行链接的步骤，链接简单地说，就是将已经加载的java二进制代码组合到JVM运行状态中去。它包括3个步骤：</p><ul><li>验证（Verification），验证是保证二进制字节码在结构上的正确性，具体来说，工作包括检测类型正确性，接入属性正确性（public、private），检查final class 没有被继承，检查静态变量的正确性等。</li><li>准备（Preparation），准备阶段主要是创建静态域，分配空间，给这些域设默认值，需要注意的是两点：一个是在准备阶段不会执行任何代码，仅仅是设置默认值，二个是这些默认值是这样分配的，原生类型全部设为0，如：float:0f,int 0, long 0L, boolean:0（布尔类型也是0），其它引用类型为null。</li><li>解析（Resolution），解析的过程就是对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址），并保证这些类被正确的找到。解析的过程可能导致其它的类被加载。需要注意的是，根据不同的解析策略，这一步不一定是必须的，有些解析策略在解析时递归的把所有引用解析，这是early resolution，要求所有引用都必须存在；还有一种策略是late resolution，这也是Oracle 的JDK所采取的策略，即在类只是被引用了，还没有被真正用到时，并不进行解析，只有当真正用到了，才去加载和解析这个类。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>static{}是在第一次初始化时执行的，且执行一次；</p><p>未完待续。。。。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;&lt;/p&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;尽管一直在学java、用java，但对于底层的东西却仍处于一知半解的状态。&lt;br&gt;显然这样下去是不行的，如果只为了敲代码而敲代码。可以预见今后的工作中只会陷入一种死循环–敲代码、出Bug、改Bug、改不好、重新敲、出Bug，然后改、改不好，最后就只能是改不动自闭、改不动自闭and改不动自闭。  &lt;/p&gt;
&lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;p&gt;在了解Java的机制之前，需要先了解类在JVM（Java虚拟机）中是如何加载的，这对后面理解java其它机制将有重要作用。&lt;/p&gt;
&lt;p&gt;每个类编译后产生一个Class对象，存储在.class文件中，JVM使用类加载器（Class Loader）来加载类的字节码文件（.class），类加载器实质上是一条类加载器链，一般的，我们只会用到一个原生的类加载器，它只加载Java API等可信类，通常只是在本地磁盘中加载，这些类一般就够我们使用了。如果我们需要从远程网络或数据库中下载.class字节码文件，那就需要我们来挂载额外的类加载器。&lt;/p&gt;
&lt;p&gt;一般来说，类加载器是按照树形的层次结构组织的，每个加载器都有一个父类加载器。另外，每个类加载器都支持代理模式，即可以自己完成Java类的加载工作，也可以代理给其它类加载器。&lt;/p&gt;
&lt;p&gt;类加载器的加载顺序有两种，一种是父类优先策略，一种是是自己优先策略，父类优先策略是比较一般的情况（如JDK采用的就是这种方式），在这种策略下，类在加载某个Java类之前，会尝试代理给其父类加载器，只有当父类加载器找不到时，才尝试自己去加载。自己优先的策略与父类优先相反，它会首先尝试自己加载，找不到的时候才要父类加载器去加载，这种在web容器（如tomcat）中比较常见。&lt;/p&gt;
&lt;h3 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h3&gt;&lt;p&gt;类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：&lt;br&gt;加载 -&amp;gt; 验证 -&amp;gt; 准备 -&amp;gt; 解析 -&amp;gt; 初始化 -&amp;gt; 使用 -&amp;gt; 卸载    &lt;/p&gt;
&lt;h3 id=&quot;动态加载&quot;&gt;&lt;a href=&quot;#动态加载&quot; class=&quot;headerlink&quot; title=&quot;动态加载&quot;&gt;&lt;/a&gt;动态加载&lt;/h3&gt;&lt;p&gt;不管使用什么样的类加载器，类，都是在第一次被用到时，动态加载到JVM的。这句话有两层含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java程序在运行时并不一定被完整加载，只有当发现该类还没有加载时，才去本地或远程查找类的.class文件并验证和加载；&lt;/li&gt;
&lt;li&gt;当程序创建了第一个对类的静态成员的引用（如类的静态变量、静态方法、构造方法——构造方法也是静态的）时，才会加载该类。Java的这个特性叫做：动态加载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要区分加载和初始化的区别，加载了一个类的.class文件，不以为着该Class对象被初始化，事实上，一个类的初始化包括3个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载（Loading），由类加载器执行，查找字节码，并创建一个Class对象（只是创建）；&lt;/li&gt;
&lt;li&gt;链接（Linking），验证字节码，为静态域分配存储空间（只是分配，并不初始化该存储空间），解析该类创建所需要的对其它类的应用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始化（Initialization），首先执行静态初始化块static{}，初始化静态变量，执行静态方法（如构造方法）。&lt;/p&gt;
&lt;h3 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h3&gt;&lt;p&gt;Java在加载了类之后，需要进行链接的步骤，链接简单地说，就是将已经加载的java二进制代码组合到JVM运行状态中去。它包括3个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证（Verification），验证是保证二进制字节码在结构上的正确性，具体来说，工作包括检测类型正确性，接入属性正确性（public、private），检查final class 没有被继承，检查静态变量的正确性等。&lt;/li&gt;
&lt;li&gt;准备（Preparation），准备阶段主要是创建静态域，分配空间，给这些域设默认值，需要注意的是两点：一个是在准备阶段不会执行任何代码，仅仅是设置默认值，二个是这些默认值是这样分配的，原生类型全部设为0，如：float:0f,int 0, long 0L, boolean:0（布尔类型也是0），其它引用类型为null。&lt;/li&gt;
&lt;li&gt;解析（Resolution），解析的过程就是对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址），并保证这些类被正确的找到。解析的过程可能导致其它的类被加载。需要注意的是，根据不同的解析策略，这一步不一定是必须的，有些解析策略在解析时递归的把所有引用解析，这是early resolution，要求所有引用都必须存在；还有一种策略是late resolution，这也是Oracle 的JDK所采取的策略，即在类只是被引用了，还没有被真正用到时，并不进行解析，只有当真正用到了，才去加载和解析这个类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;static{}是在第一次初始化时执行的，且执行一次；&lt;/p&gt;
&lt;p&gt;未完待续。。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java JVM" scheme="http://seasontemple.top/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>SSM</title>
    <link href="http://seasontemple.top/2019/05/10/SSM/"/>
    <id>http://seasontemple.top/2019/05/10/SSM/</id>
    <published>2019-05-10T14:06:30.000Z</published>
    <updated>2019-05-10T14:28:23.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Emmmmm"><a href="#Emmmmm" class="headerlink" title="Emmmmm"></a>Emmmmm</h1><p>&emsp;今天准备分享的是正在研究中的基于SSM框架开发一个网站项目</p><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><p>先简单介绍一下什么是SSM框架：<br>&emsp;&emsp;SSM是指Spring、SpringMvc、Mybaits，这三。</p><h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h2><ul><li><strong>登录界面</strong>：<br>哈哈，也就是做个样子<br><img src="/2019/05/10/SSM/LoginPage.png" alt="登录界面"></li><li><strong>主页面</strong>：<br>照着一个不错模板做的，可惜用的前端框架不同，不能100%再现<br><img src="/2019/05/10/SSM/HomePage.png" alt="主页面"></li><li><strong>侧边栏</strong>：<br>侧边栏是找的模板，不过原理也比较简单，利用的就是Bootstrap的竖向导航栏，类名是nav<br><img src="/2019/05/10/SSM/SliderBar.png" alt="侧边栏"></li><li><strong>列表</strong>：<br>点击侧边栏，在页面中显示相应内容<br><img src="/2019/05/10/SSM/StudentList.png" alt="学生列表"><h3 id="今天就这样子，有空再改"><a href="#今天就这样子，有空再改" class="headerlink" title="今天就这样子，有空再改"></a>今天就这样子，有空再改</h3></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Emmmmm&quot;&gt;&lt;a href=&quot;#Emmmmm&quot; class=&quot;headerlink&quot; title=&quot;Emmmmm&quot;&gt;&lt;/a&gt;Emmmmm&lt;/h1&gt;&lt;p&gt;&amp;emsp;今天准备分享的是正在研究中的基于SSM框架开发一个网站项目&lt;/p&gt;
&lt;h2 id=&quot;SSM&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JEE——SSM" scheme="http://seasontemple.top/tags/JEE%E2%80%94%E2%80%94SSM/"/>
    
  </entry>
  
  <entry>
    <title>My First Blog</title>
    <link href="http://seasontemple.top/2019/05/05/My-First-Blog/"/>
    <id>http://seasontemple.top/2019/05/05/My-First-Blog/</id>
    <published>2019-05-05T08:18:54.000Z</published>
    <updated>2019-05-10T14:08:23.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>&emsp;本文主要为测试Markdown以及Hexo的效果</p><h2 id="其次"><a href="#其次" class="headerlink" title="其次"></a>其次</h2><p>&emsp;Markdwon 是一种轻量级<strong>标记语言</strong>，它以纯文本形式（易读、易写、易更改）编写文档，并最终以HTLM格式发布。<br>&emsp;顺便了解一下Markdown的由来：<br>&emsp;Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。它是由 Aaron Swartz 和 John Gruber共同设计。<br>&emsp;Aaron Swartz就是那位（2013年1月11日）自杀，有着开挂一般人生经历的程序员。<br>&emsp;维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。  </p><ul><li>14岁参与RSS 1.0规格标准制订。</li><li>2004年入读斯坦福大学，之后退学。</li><li>2005年创建 Infogami,之后与Reddit合并成为其合伙人。</li><li>2010年创立示进会（DemandPreogress）,积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。</li><li>2011年7月19日,因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。</li><li>2013年1月自杀身亡。<h2 id="Markdwon语法"><a href="#Markdwon语法" class="headerlink" title="Markdwon语法"></a>Markdwon语法</h2><blockquote><p>由于Markdwon是标记语言，而看到它的语法时我首先想到的就是Html中的标签。显然，要是写博文还要去折腾出一个页面，写一大堆的css之类的，那就违背了写博文的初衷了。因此，Markdwon确实十分的方便，只需要通过使用各种标记就能做出较为美观的文本效果，哪还有什么理由不学呢？  </p></blockquote></li></ul><p>Markdown语法分为如下几个部分：  </p><ul><li>标题</li><li>段落</li><li>区块引用</li><li>代码区块</li><li>强调</li><li>列表</li><li>分割线</li><li>链接</li><li>图片</li><li>反斜杠</li><li>符号</li><li>表格</li><li>流程图</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&emsp;这些文档作者是真的不省心</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;首先&quot;&gt;&lt;a href=&quot;#首先&quot; class=&quot;headerlink&quot; title=&quot;首先&quot;&gt;&lt;/a&gt;首先&lt;/h1&gt;&lt;p&gt;&amp;emsp;本文主要为测试Markdown以及Hexo的效果&lt;/p&gt;
&lt;h2 id=&quot;其次&quot;&gt;&lt;a href=&quot;#其次&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Test Hexo" scheme="http://seasontemple.top/tags/Test-Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://seasontemple.top/2019/04/30/hello-world/"/>
    <id>http://seasontemple.top/2019/04/30/hello-world/</id>
    <published>2019-04-30T14:09:05.442Z</published>
    <updated>2019-04-30T14:09:05.442Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
